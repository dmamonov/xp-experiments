Extension methods
========================================================================
This experiment evaluates the possibility to add extension methods to 
the XP Framework's core.

Motivation
----------
The following calls a method called "sorted" on an instance of the
lang.types.ArrayList class. The ArrayList class doesn't have such a
method, and we'll thus get a nice "call to undefined method" error
shortly before our program is terminated.

<code>
  $array= new ArrayList(3, 1, 2);
  $sorted= $array->sorted();
</code>

Of course we can add this method to the class, but the next request
would be to have filter(), map(), join(), collect(), partition(), and
whatever else methods in this class, which would turn it into the 
"swiss army knife" anti-pattern. Of course adding functionality can 
also be accomplished by subclassing or by creating an adapter which 
delegates all calls to the ArrayList class but the ones it wants to
implement on top. 

The subclass
~~~~~~~~~~~~
<code>
  class SortableArrayList extends ArrayList {
    public static function from(ArrayList $in) {
      $s= new self();
      $s->values= $in->values;
      $s->size= $in->size;
      return $s;
    }
    public function sorted() { ... }
  }
  
  $array= new ArrayList(3, 1, 2);
  $sorted= SortableArrayList::from($array)->sorted(); 
</code>

The delegate
~~~~~~~~~~~~  
<code>
  class SortableArrayList extends Object {
    public function __construct(ArrayList $delegate) {
      $this->delegate= $delegate;
    }
    public function __call($name, $args) {
      return call_user_func_array(array($this->delegate, $name), $args);
    }
    public function sorted() { ...} 
  }
  
  $array= new ArrayList(3, 1, 2);
  $sorted= create(new SortableArrayList($array))->sorted();  
</code>

Following the "one class, one responsibility" we could also refactor
the code out into an ArrayHelper class with all kinds of static helper 
functions or into an ArraySorter, an ArrayFilterer, and so on. We
wouldn't really be adding functionality in these cases, but let's have
a look at them nevertheless:

The helper class
~~~~~~~~~~~~~~~~
<code>
  class Arrays extends Object {
    public static function sort(ArrayList $in) { ...} 
  }
  
  $array= new ArrayList(3, 1, 2);
  $sorted= Arrays::sort($array);
</code>

The sorter
~~~~~~~~~~
<code>
  class ArraySorter extends Object {
    public function sort(ArrayList $in) { ...} 
  }
  
  $array= new ArrayList(3, 1, 2);
  $sorted= create(new ArraySorter())->sort($array);
</code>

In any of these situations, we have to write more sourcecode. Sourcecode 
not only for the extension itself but also when using it. Programmers 
can be safely said to be of the type of person who are lazy (or else 
we'd be shifting the bytes ourselves and not letting a programming 
language do the job, right?)

Anatomy
-------
Extension methods let you "add" methods to existing types without having
to change the respective type itself. They are declared in a regular 
class as public static methods, albeit being called as if they were 
instance methods on objects of the type they extend. Seen from the 
outside, using extension methods does not differ from calling methods
actually defined inside that type.



See also
--------
* http://msdn.microsoft.com/en-us/library/bb383977.aspx
