XP Language experiment
========================================================================
This is the XP language - a compiled programming language built on top 
of the XP Framework and written using it; inspired and still close to PHP 
but also with elements from the Java and C# worlds. At the same time, this
experiment also proves how PHP can be used as a platform, with different
possible input syntaxes generating intermediate code to run inside it, and 
be able to re-use code written in other syntaxes but also plain old PHP,
but sharing the XP Framework's foundation classes as a common SDK.

Overview
--------
Here's a list of the subdirectories inside this one and what you will 
find inside:
<pre>
  - tests   : Unittests
  - cmd     : Utility xpclis
  - demo    : Examples
  - grammar : Grammars
  - xp      : Implementation
</pre>

Prerequisites
-------------
You will need the Opcode Engineering Library extension (short: <tt>oel</tt>)
compiled into PHP. You will find the sourcecode inside the Ruben's experiment
directory (../../people/wagner/oel-extension).

Building (shown for Windows, almost the same as on Un*x though):
<pre>
  $ cd ~/devel/php/php_5_2
  $ cp -r ~/devel/xp.forge/trunk/experiments/people/wagner/oel-extension/oel_ct/src/oel ext
  $ cscript /nologo configure.js --enable-oel
  $ nmake
</pre>

After the build has succeeded, change the XP runtime by adding the 
following section to your <tt>xp.ini</tt>:
<pre>
  [runtime]
  oel=F:/cygwin/home/Timm Friebe/devel/php/php_5_2/Release_TS/php.exe
</pre>


Motivation
----------
Designing the XP programming language we had the following goals in mind:

* Get rid of the oddities in PHP - alternative syntaxes like if / endif 
  for example or "__"-magic.
* Overcome limitations in the PHP grammar that do not allow chaining at
  all points like method calls after new() and array access after method
  calls.
* Support syntactically what the XP framework has built ontop of PHP:
  annotations, type-safe enums, return types, thrown exceptions, finallly,
  with() blocks.
* Integrate with the XP Framework's foundation classes.
* Keep the "change and run" spirit and the ability for rapid development.

Generally speaking, we've tried to follow the "less is more" principle and
tried making the syntax more concise as to what it's doing.


Getting started
---------------
Like in the XP framework, the entry point is always a class. In their most
simple form, these classes have a static <tt>main()</tt> method. An example:

<code>
  public class HelloWorld {
    public static void main(string[] $args) {
      util.cmd.Console::writeLine('Hello World from ', self::$class.getName(), '!');
    }
  }
</code>

Now you will already start noticing things:
* Classes may also have modifiers.
* The "extends Object" is optional and added by the compiler if omitted.
* The keyword "function" is gone and replaced by the return type. Because
  the main() method does not return anything, we use "void".
* An array type is written as component[]
* Variables still have dollar signs. This makes it easy to spot them,
  that's why we've decided to keep this!
* Fully qualified classnames are written with dots.
* The object operator is also a dot (at the same time, the string 
  concatenation operator is now the tilde, ~).

This is not everything though, to get an impression on the language's
"look and feel" have a look at the examples in the <tt>demo</tt> 
subdirectory.


Features
--------
Alongside with the afforementioned goals here's a an overview of what
the XP language supports.

Chaining
~~~~~~~~
It is now syntactically possible to continue writing after <tt>new</tt>
and to use array offsets on method return values:

<code>
  new Date().toString();
  XPClass::forName($name).getMethods()[0];
</code>

Array syntax
~~~~~~~~~~~~
The <tt>array</tt> keyword from the PHP language has been replaced by
the shorter form with square brackets. By means of an extension array
length can be determined by using the <tt>length</tt> pseudo-member.

<code>
  $a= [1, 2, 3];    // same as $a= array(1, 2, 3);
  $i= $a.length;    // same as $i= sizeof($i);
</code>

Class literal
~~~~~~~~~~~~~
Every class has a static member called <tt>$class</tt> which will 
retrieve the <tt>lang.XPClass</tt> object associated with it.

<code>
  // same as $c= XPClass::forName(xp::nameOf(__CLASS__));
  $c= self::$class;
  
  // same as $c= XPClass::forName('lang.types.String');
  $c= lang.types.String::$class;
</code>

Finally: Finally
~~~~~~~~~~~~~~~~
Especially for cleaning up - and yes, even in 2009 with the amount of
memory and computing power we have available - it is still necessary to
ensure, for example, file handles are properly closed:

<code>
  $f= new File($name);
  try {
    $f->open(FileMode::READ);
    return $f->read(0xFF);
  } finally {
    $f->close();
  }
</code>

Imports
~~~~~~~
Importing is a compile-time feature to enable to use short versions
of names but actually mean the longer ones. The "Hello World" example
from above could be rewritten as follows:

<code>
  import util.cmd.Console;
  
  public class HelloWorld {
    public static void main(string[] $args) {
      Console::writeLine(...);
    }
  }
</code>

Also available are static imports which makes writing a line to the
console even shorter to write:

<code>
  import static util.cmd.Console.writeLine;
  
  public class HelloWorld {
    public static void main(string[] $args) {
      writeLine(...);
    }
  }
</code>


Hacking
-------
When changing the grammar file you need to regenerate the parser:
<pre>
  $ make grammar
</pre>
