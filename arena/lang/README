XP Language experiment
========================================================================
This is the XP language - a compiled programming language built on top 
of the XP Framework and written using it; inspired and still close to PHP 
but also with elements from the Java and C# worlds. At the same time, this
experiment also proves how PHP can be used as a platform, with different
possible input syntaxes generating intermediate code to run inside it, and 
be able to re-use code written in other syntaxes but also plain old PHP,
but sharing the XP Framework's foundation classes as a common SDK.

Overview
--------
Here's a list of the subdirectories inside this one and what you will 
find inside:
<pre>
  - tests   : Unittests
  - cmd     : Utility xpclis
  - demo    : Examples
  - grammar : Grammars
  - xp      : Implementation
</pre>

Prerequisites
-------------
You will need the Opcode Engineering Library extension (short: <tt>oel</tt>)
compiled into PHP. You will find the sourcecode inside the Ruben's experiment
directory (../../people/wagner/oel-extension).

Building (shown for Windows, almost the same as on Un*x though):
<pre>
  $ cd ~/devel/php/php_5_2
  $ cp -r ~/devel/xp.forge/trunk/experiments/people/wagner/oel-extension/oel_ct/src/oel ext
  $ cscript /nologo configure.js --enable-oel
  $ nmake
</pre>

After the build has succeeded, change the XP runtime by adding the 
following section to your <tt>xp.ini</tt>:
<pre>
  [runtime]
  oel=F:/cygwin/home/Timm Friebe/devel/php/php_5_2/Release_TS/php.exe
</pre>


Motivation
----------
Designing the XP programming language we had the following goals in mind:

* Get rid of the oddities in PHP - alternative syntaxes like if / endif 
  for example or "__"-magic.
* Overcome limitations in the PHP grammar that do not allow chaining at
  all points like method calls after new() and array access after method
  calls.
* Support syntactically what the XP framework has built ontop of PHP:
  annotations, type-safe enums, return types, thrown exceptions, finallly,
  with() blocks.
* Integrate with the XP Framework's foundation classes.
* Keep the "change and run" spirit and the ability for rapid development.

Generally speaking, we've tried to follow the "less is more" principle and
tried making the syntax more concise as to what it's doing.


Getting started
---------------
Like in the XP framework, the entry point is always a class. In their most
simple form, these classes have a static <tt>main()</tt> method. An example:

<code>
  public class HelloWorld {
    public static void main(string[] $args) {
      util.cmd.Console::writeLine('Hello World from ', self::$class.getName(), '!');
    }
  }
</code>

Now you will already start noticing things:
* Classes may also have modifiers.
* The "extends Object" is optional and added by the compiler if omitted.
* The keyword "function" is gone and replaced by the return type. Because
  the main() method does not return anything, we use "void".
* An array type is written as component[]
* Variables still have dollar signs. This makes it easy to spot them,
  that's why we've decided to keep this!
* Fully qualified classnames are written with dots.
* The object operator is also a dot (at the same time, the string 
  concatenation operator is now the tilde, ~).

This is not everything though, to get an impression on the language's
"look and feel" have a look at the examples in the <tt>demo</tt> 
subdirectory.


Features
--------
Alongside with the afforementioned goals here's a an overview of what
the XP language supports.

Chaining
~~~~~~~~
It is now syntactically possible to continue writing after <tt>new</tt>
and to use array offsets on method return values:

<code>
  new Date().toString();
  XPClass::forName($name).getMethods()[0];
</code>

Array syntax
~~~~~~~~~~~~
The <tt>array</tt> keyword from the PHP language has been replaced by
the shorter form with square brackets. By means of an extension array
length can be determined by using the <tt>length</tt> pseudo-member.

<code>
  $a= [1, 2, 3];    // same as $a= array(1, 2, 3);
  $i= $a.length;    // same as $i= sizeof($a);
</code>

Varargs syntax
~~~~~~~~~~~~~~
To create functions that accept a variable amount of arguments - 
<tt>printf</tt> is probably the most famous one of them, you have to
resort to <tt>func_get_args()</tt> in PHP userland. The XP language
supports this feature by adding <tt>...</tt> to the parameter's type:

<code>
  public class Format {
  
    public static string printf(string $format, var... $values) {
      // Implementation here
    }
    
    public static void main(string[] $args) {
      Format::sprintf('%d args passed to %s', $args.length, self::$class.getName());
    }
  }
</code>

This will make the <tt>format</tt> variable contain the format string and 
the <tt>values</tt> an array with two values (the length and the class name).

Class literal
~~~~~~~~~~~~~
Every class has a static member called <tt>$class</tt> which will 
retrieve the <tt>lang.XPClass</tt> object associated with it.

<code>
  // same as $c= XPClass::forName(xp::nameOf(__CLASS__));
  $c= self::$class;
  
  // same as $c= XPClass::forName('lang.types.String');
  $c= lang.types.String::$class;
</code>

Finally: Finally
~~~~~~~~~~~~~~~~
Especially for cleaning up - and yes, even in 2009 with the amount of
memory and computing power we have available - it is still necessary to
ensure, for example, file handles are properly closed:

<code>
  $f= new File($name);
  try {
    $f->open(FileMode::READ);
    return $f->read(0xFF);
  } finally {
    $f->close();
  }
</code>

Imports
~~~~~~~
Importing is a compile-time feature to enable to use short versions
of names but actually mean the longer ones. The "Hello World" example
from above could be rewritten as follows:

<code>
  import util.cmd.Console;
  
  public class HelloWorld {
    public static void main(string[] $args) {
      Console::writeLine(...);
    }
  }
</code>

Also available are static imports which makes writing a line to the
console even shorter to write:
<code>
  import static util.cmd.Console.writeLine;
  
  public class HelloWorld {
    public static void main(string[] $args) {
      writeLine(...);
    }
  }
</code>

At the same time, to avoid name clashes with PHP's native functions,
these also need to be imported:
<code>
  import native standard.substr;
  import native mysql.mysql_connect;
</code>

To enable rapid prototyping, type import on demand can be used:
<code>
  import util.*;
  import static util.cmd.Console.*;
  import native sybase_ct.*;
</code>

Enumerations
~~~~~~~~~~~~
The XP framework already offers type-safe enumerations. These were
originally introduced in RFC #0132 and are now supported with an easier-
to-type syntax:

<code>
  public enum Weekday {
    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
  }
</code>

Enumerations may also have methods:
<code>
  public enum Coin {
    penny(1), nickel(2), dime(10), quarter(25);
    
    public string color() {
      switch ($this) {
        case self::$penny: return 'copper';
        case self::$nickel: return 'nickel';
        case self::$dime: case self::$quarter: return 'silver';
      }
    }
  }
</code>

Members can have methods attached, too:
<code>
  public abstract enum Operation {
    plus {
      public int evaluate(int $x, int $y) { return $x + $y; }
    },
    minus {
      public int evaluate(int $x, int $y) { return $x - $y; }
    };
    
    public abstract int evaluate(int $x, int $y);
  }
</code>

Annotations
~~~~~~~~~~~
Also supported for quite a while in the XP Framework are annotations.
They use "#" one-line comments and are parsed from the class' source when 
accessed inside the reflection API (see also RFC #0016). The XP language 
can do without this workaround, of course!

<code>
  public class ArrayListTest extends unittest.TestCase {
  
    [@test] public void emptyList() {
      $this.assertEquals([], new ArrayList().values);
    }
  }
</code>

Anonymous instance creation
~~~~~~~~~~~~~~~~~~~~~~~~~~~
To generate "throw-away" instances the XP framework provides the 
<tt>newinstance()</tt> functionality, originally described in RFC #0080.
With the downside of having to declare the class body inside a string
and the added overhead of runtime evaluation, this feature is now not
only more elegant to write but classes created this way will also be 
declared at compile time:

<code>
  $emptyFiles= new io.collections.iterate.IterationFilter() {
    public bool accept(io.collections.IOElement $e) {
      return 0 == $e.size;
    }
  };
</code>

Properties
~~~~~~~~~~
Properties are special member variables that instead of directly
accessing a class field may have methods attached. This way, we can
create short syntax but still stay flexible if we need to change
the underlying implementation.

<code>
  import native standard.strlen;
  
  public class String {
    protected string $buffer;
    
    public __construct(string $initial= '') {
      $this.buffer= $initial;
    }
  
    public string length {
      get { return strlen($this.buffer); }
      set { throw new IllegalAccessException('Cannot set string length!'); }
    }
    
    public static void main(string[] $args) {
      $s= new String('Hello');
      $l= $s.length;   // 5
      $s.length= 1;    // *** IllegalAccessException
    }
  }
</code>

Internally, this is implemented by compiling <tt>__get()</tt> and 
<tt>__set()</tt> interceptors.

Indexers
~~~~~~~~
The PHP language allows for userland overloading of array operations
via the <tt>ArrayAccess</tt> interface and its <tt>offset*</tt> methods.
This is kind of different from the usual PHP approach with <tt>__</tt>
"magic" methods - in the XP language, it's the property syntax again:

<code>
  public class ArrayList<T> {
    protected T[] $elements;
  
    public __construct(T... $initial) {
      $this.elements= $initial;
    }
    
    public this[int $offset] {
      get   { return $this.elements[$offset]; }
      set   { $this.elements[$offset]= $value; }
      isset { return $offset >= 0 && $offset < $this.elements.length; }
      unset { throw new IllegalAccessException('Immutable'); }
    }
    
    public static void main(string[] $args) {
      $a= new ArrayList<string>('One', 'Two', 'Three');
      $one= $a[0];      // 'One'
      $a[2]= 'Drei';    // Now: One, Two, Drei
    }
  }
</code>


Hacking
-------
When changing the grammar file you need to regenerate the parser:
<pre>
  $ make grammar
</pre>
