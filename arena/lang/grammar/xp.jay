%{
  uses(
    'xp.compiler.types.TypeName',
    'xp.compiler.ast.ParseTree',
    'xp.compiler.ast.PackageNode',
    'xp.compiler.ast.ImportNode',
    'xp.compiler.ast.StaticImportNode',
    'xp.compiler.ast.NativeImportNode',
    'xp.compiler.ast.AnnotationNode',
    'xp.compiler.ast.ClassNode',
    'xp.compiler.ast.EnumNode',
    'xp.compiler.ast.EnumMemberNode',
    'xp.compiler.ast.InterfaceNode',
    'xp.compiler.ast.FieldNode',
    'xp.compiler.ast.PropertyNode',
    'xp.compiler.ast.ConstructorNode',
    'xp.compiler.ast.MethodNode',
    'xp.compiler.ast.OperatorNode',
    'xp.compiler.ast.ReturnNode',
    'xp.compiler.ast.InstanceCreationNode',
    'xp.compiler.ast.VariableNode',
    'xp.compiler.ast.ArrayAccessNode',
    'xp.compiler.ast.TryNode',
    'xp.compiler.ast.CatchNode',
    'xp.compiler.ast.ThrowNode',
    'xp.compiler.ast.FinallyNode',
    'xp.compiler.ast.ForNode',
    'xp.compiler.ast.ForeachNode',
    'xp.compiler.ast.DoNode',
    'xp.compiler.ast.WhileNode',
    'xp.compiler.ast.AssignmentNode',
    'xp.compiler.ast.InvocationNode',
    'xp.compiler.ast.NumberNode',
    'xp.compiler.ast.HexNode',
    'xp.compiler.ast.DecimalNode',
    'xp.compiler.ast.StringNode',
    'xp.compiler.ast.ArrayNode',
    'xp.compiler.ast.MapNode',
    'xp.compiler.ast.ClassMemberNode',
    'xp.compiler.ast.InstanceOfNode',
    'xp.compiler.ast.ComparisonNode',
    'xp.compiler.ast.BinaryOpNode',
    'xp.compiler.ast.BooleanOpNode',
    'xp.compiler.ast.UnaryOpNode',
    'xp.compiler.ast.TernaryNode',
    'xp.compiler.ast.SwitchNode',
    'xp.compiler.ast.CaseNode',
    'xp.compiler.ast.DefaultNode',
    'xp.compiler.ast.BreakNode',
    'xp.compiler.ast.ContinueNode',
    'xp.compiler.ast.IfNode',
    'xp.compiler.ast.ElseNode'
  );
%}

%left ',' '=' '%' '?' ':' T_ADD_EQUAL T_SUB_EQUAL T_MUL_EQUAL T_DIV_EQUAL T_MOD_EQUAL T_BOOLEAN_OR T_BOOLEAN_AND T_INSTANCEOF T_CONCAT_EQUAL
%left '+' '-'
%left '*' '/'
%right '[' '!' '~' T_INC T_DEC 
%nonassoc '<' '>' T_SE T_GE '.' T_EQUALS T_NOT_EQUALS 

%token T_WORD 260
%token T_STRING 261
%token T_NUMBER 262
%token T_DECIMAL 263
%token T_HEX 264

%token T_PUBLIC 280
%token T_PRIVATE 281
%token T_PROTECTED 282
%token T_STATIC 283
%token T_FINAL 284
%token T_ABSTRACT 285
%token T_NATIVE 286
%token T_INLINE 287

%token T_CLASS 300
%token T_INTERFACE 301
%token T_ENUM 302
%token T_PACKAGE 303
%token T_IMPORT 304

%token T_EXTENDS 310
%token T_IMPLEMENTS 311
%token T_INSTANCEOF 312

%token T_OPERATOR 320
%token T_THROWS 321

%token T_DOTS 330

%token T_VARIABLE 340
%token T_RETURN 341
%token T_TRY 342
%token T_THROW 343
%token T_CATCH 344
%token T_FINALLY 345
%token T_NEW 346

%token T_FOR 360
%token T_WHILE 361
%token T_DO 362
%token T_FOREACH 363
%token T_IN 364
%token T_BREAK 365
%token T_CONTINUE 366

%token T_IF 370
%token T_ELSE 371
%token T_SWITCH 372
%token T_CASE 373
%token T_DEFAULT 374

%token T_GE 400
%token T_SE 401
%token T_INC 402
%token T_DEC 403
%token T_ADD_EQUAL 404
%token T_SUB_EQUAL 405
%token T_MUL_EQUAL 406
%token T_DIV_EQUAL 407
%token T_MOD_EQUAL 408
%token T_DOUBLE_COLON 410
%token T_EQUALS 411
%token T_NOT_EQUALS 412
%token T_DOUBLE_ARROW 413
%token T_BOOLEAN_OR 414
%token T_BOOLEAN_AND 415
%token T_CONCAT_EQUAL 416

%%

start:
    package_opt imports_opt declaration {
      $$= new ParseTree();
      $$->origin= $yyLex->fileName;
      $$->package= $1;
      $$->imports= $2;
      $$->declaration= $3;
    }
;

// {{{ Packages, imports
package_opt:
    /* empty */
  | T_PACKAGE { $1= $yyLex->create(new PackageNode()); } qualifiedname ';' {
    $1->name= $3;
  }
;

imports_opt:
    /* empty */
  | imports
;

imports:
    import { $$= array($1); }
  | import imports { $$= array_merge(array($1), $2); }
;

import:
    T_IMPORT { $p= $yyLex->position; } importtype T_WORD '.' importname ';' {
      $3->position= $p;
      $3->name= $4.'.'.$6;
      $$= $3;
    }
;

importtype:
    /* empty */ { $$= new ImportNode(); }
  | T_STATIC    { $$= new StaticImportNode(); }
  | T_NATIVE    { $$= new NativeImportNode(); }
;

importname:
    T_WORD
  | '*'
  | T_WORD '.' importname { $$= $1.'.'.$3; }
;

qualifiedname:
    T_WORD
  | T_WORD '.' qualifiedname { $$= $1.'.'.$3; }
;
// }}}

// {{{ Class, enum and interface declarations
declaration:
    decorations T_CLASS { $2= $yyLex->create(new ClassNode()); } typename classparents_opt implements_opt '{' classbody '}' {
      $2->modifiers= $1[0];
      $2->annotations= $1[1];
      $2->name= $4;
      $2->parent= $5;
      $2->implements= $6;
      $2->body= $8;
      $$= $2;
    }
  | decorations T_ENUM { $2= $yyLex->create(new EnumNode()); } typename classparents_opt implements_opt '{' enumbody '}' {
      $2->modifiers= $1[0];
      $2->annotations= $1[1];
      $2->name= $4;
      $2->parent= $5;
      $2->implements= $6;
      $2->body= $8;
      $$= $2;
    }
  | decorations T_INTERFACE { $2= $yyLex->create(new InterfaceNode()); } typename interfaceparents_opt '{' classbody '}' {
      $2->modifiers= $1[0];
      $2->annotations= $1[1];
      $2->name= $4;
      $2->parents= $5;
      $2->body= $7;
      $$= $2;
    }
;

classparents_opt:
    /* empty */    { $$= NULL; }
  | T_EXTENDS typename { $$= $2; }
;

implements_opt:
    /* empty */ { $$= array(); }
  | T_IMPLEMENTS name_list { $$= $2; }
;

interfaceparents_opt:
    /* empty */    { $$= NULL; }
  | T_EXTENDS name_list { $$= $2; }
;

classbody_opt:
    /* empty */       { $$= NULL; }
  | '{' classbody '}' { $$= $2; }
;

classbody:
    classbody classmember { $k= key($2); $$[$k][]= $2[$k]; }
  | /* empty */ { $$= NULL; }
;

classmember:
    field { $$= array('fields' => $1); }
  | method { $$= array('methods' => $1); }
  | T_STATIC '{' statements_opt '}' { $$= array('static' => $3); }
;

enumbody:
    enummembers ';' classbody { $3['members']= $1; $$= $3; }
  | enummembers { $$= array('members' => $1); }
  | /* empty */ { $$= NULL; }
;

enummembers:
    enummember { $$= array($1); }
  | enummember ',' enummembers { $$= array_merge(array($1), $3); }
;

enummember:
    T_WORD { $1= $yyLex->create(new EnumMemberNode(array('name' => $1))); } classbody_opt {
      $1->body= $3;
    }
  | T_WORD { $1= $yyLex->create(new EnumMemberNode(array('name' => $1))); } '(' expression ')' classbody_opt {
      $1->value= $4;
      $1->body= $6;
    }
;
    
// }}}

// {{{ Fields and properties
field:
    decorations typeref T_VARIABLE initialization_opt ';' { $$= $yyLex->create(new FieldNode());
      $$->modifiers= $1[0];
      $$->annotations= $1[1];
      $$->type= $2;
      $$->name= $3;
      $$->initialization= $4;
    }
  | decorations typeref property '{' getsets '}' {
      $3->modifiers= $1[0];
      $3->annotations= $1[1];
      $3->type= $2;
      $3->handlers= $5;
      $$= $3;
    }
;

property:
    T_WORD { $$= $yyLex->create(new PropertyNode(array('name' => $1))); }
  | T_WORD '[' arguments ']' { $$= $yyLex->create(new PropertyNode(array('name' => $1, 'arguments' => $3))); }
;

getsets:
    getset         { $$= $1; }
  | getset getsets { $$= array_merge($1, $2); }
;

getset:
	T_WORD T_VARIABLE { $$= array($1 => $2); }
  | T_WORD T_WORD '(' ')' { $$= array($1 => $2); }
  | T_WORD '{' statements_opt '}' { $$= array($1 => $3); }
;

initialization_opt:
    /* empty */    { $$= NULL; }
  | '=' expression { $$= $2; }
;
// }}}

// {{{ Methods and operators
method:
    decorations typeref T_WORD '(' { $4= $yyLex->create(new MethodNode()); } arguments_opt ')' throws_opt methodbody {
      $4->modifiers= $1[0];
      $4->annotations= $1[1];
      $4->returns= $2;
      $4->name= $3;
      $4->arguments= $6;
      $4->throws= $8;
      $4->body= $9;
      $$= $4;
    }
  | decorations T_WORD '(' { if ('__construct' == $2) $3= $yyLex->create(new ConstructorNode()); } arguments_opt ')' throws_opt methodbody {
      $3->modifiers= $1[0];
      $3->annotations= $1[1];
      $3->arguments= $5;
      $3->throws= $7;
      $3->body= $8;
      $$= $3;
    }
  | decorations typeref T_OPERATOR operator '(' { $5= $yyLex->create(new OperatorNode()); } arguments_opt ')' throws_opt methodbody {
      $5->modifiers= $1[0];
      $5->annotations= $1[1];
      $5->returns= $2;
      $5->symbol= $4;
      $5->arguments= $7;
      $5->throws= $9;
      $5->body= $10;
      $$= $5;
    }
;

decorations:
    '[' annotations ']' modifiers_opt { $$= array($4, $2); }
  | modifiers_opt { $$= array($1, NULL); }
;

annotations:
    annotation  { $$= array($1); }
  | annotation ',' annotations { $$= array_merge(array($1), $3); }
;

annotation:
    '@' qualifiedname { 
      $$= $yyLex->create(new AnnotationNode()); 
      $$->type= $2; 
    }
  | '@' qualifiedname '(' expression_opt ')' { 
      $$= $yyLex->create(new AnnotationNode()); 
      $$->type= $2; 
      $4 && $$->parameters= array('default' => $4);
    }
  | '@' qualifiedname '(' mapliteral ')' { 
      $$= $yyLex->create(new AnnotationNode()); 
      $$->type= $2; 
      $$->parameters= $4;
    }
;

methodbody:
    ';' { $$= NULL; }
  | '{' statements_opt '}' { $$= $2; }
;

arguments_opt:
    /* empty */ { $$= NULL; }
  | arguments   { $$= $1; }
;

arguments:
    argument  { $$= array($1); }
  | argument ',' arguments { $$= array_merge(array($1), $3); }
;

argument:
	typeref T_VARIABLE initialization_opt { $$= array('name' => $2, 'type' => $1); $3 && $$['default']= $3; }
  | typeref T_DOTS '.' T_VARIABLE { $$= array('name' => $4, 'type' => $1, 'vararg' => TRUE); }
;

throws_opt:
    /* empty */ { $$= NULL; }
  | T_THROWS name_list   { $$= $2; }
;
// }}}

// {{{ Overloadable operators
operator:
	'+'
  | '-'
  | '*'
  | '/'
  | '%'
  | '~'
  | '[' ']' { $$= '[]'; }
  | '[' argument ']' { $$= $2; }
;
// }}}

// {{{ Statements
// Note: Standalone literals are really no-ops and can be optimized away. 
// Still, we do allow them
statements_opt:
    /* empty */ { $$= NULL; }
  | statements
;

statements:
    statement { $$= array($1); }
  | statement statements { $$= array_merge(array($1), $2); }
;

statement:
    T_RETURN { $1= $yyLex->create(new ReturnNode()); } expression_opt ';' { 
      $$->expression= $3;
    }
  | T_IF { $1= $yyLex->create(new IfNode()); } '(' expression ')' block else_opt {
      $1->condition= $4;
      $1->statements= $6;
      $1->otherwise= $7;
    }
  | T_FOR { $1= $yyLex->create(new ForNode()); } '(' expressionlist_opt ';' expressionlist_opt ';' expressionlist_opt ')' block {
      if ($4) {
        $1->initialization= array();
        foreach ($4 as $stmt) {
          $stmt->free= TRUE;
          $1->initialization[]= $stmt;
        }
      }
      if ($8) {
        $1->loop= array();
        foreach ($8 as $stmt) {
          $stmt->free= TRUE;
          $1->loop[]= $stmt;
        }
      }
      $1->condition= $6;
      $1->statements= $10;
    }
  | T_FOREACH { $1= $yyLex->create(new ForeachNode()); } '(' T_VARIABLE T_IN expression ')' block {
      $1->expression= $6;
      $1->assignment= $4;
      $1->statements= $8;
    }
  | T_WHILE { $1= $yyLex->create(new WhileNode()); } '(' expression ')' block {
      $1->expression= $4;
      $1->statements= $6;
    }
  | T_DO { $1= $yyLex->create(new DoNode()); } block T_WHILE '(' expression ')' {
      $1->expression= $6;
      $1->statements= $3;
    }
  | T_SWITCH { $1= $yyLex->create(new SwitchNode()); } '(' expression ')' '{' cases_opt '}' {
      $1->expression= $4;
      $1->cases= $7;
    }
  | T_TRY '{' { $2= $yyLex->create(new TryNode()); } statements_opt '}' handleexception { 
      $2->statements= $4;
      $2->handling= $6;
      $$= $2; 
    }
  | T_BREAK { $1= $yyLex->create(new BreakNode()); } ';'
  | T_CONTINUE { $1= $yyLex->create(new ContinueNode()); } ';'
  | T_THROW { $1= $yyLex->create(new ThrowNode()); } expression ';' {
      $1->expression= $3;
    }
  | expression ';' { $1->free= TRUE; }
  | ';'
;

cases_opt:
    /* empty */ { $$= NULL; }
  | cases
;

cases:
    case { $$= array($1); }
  | case cases { $$= array_merge(array($1), $2); }
;

case:
    T_CASE { $1= $yyLex->create(new CaseNode()); } expression ':' statements_opt { 
      $1->expression= $3;
      $1->statements= $5;
    }
  | T_DEFAULT { $1= $yyLex->create(new DefaultNode()); } ':' statements_opt { 
      $1->statements= $4;
    }
;

block:
    statement { $$= array($1); }
  | '{' statements_opt '}' { $$= $2; }
;
   
else_opt:
    /* empty */ { $$= NULL; }
  | T_ELSE { $1= $yyLex->create(new ElseNode()); } block { $1->statements= $3; }
;

    
handleexception:
    catches finally_opt { $2 === NULL || $$= array_merge($1, array($2)); }
  | finally { $$= array($1); }
;

catches:
    catch { $$= array($1); }
  | catch catches { $$= array_merge(array($1), $2); }
;

catch:
  T_CATCH { $1= $yyLex->create(new CatchNode()); } '(' typename T_VARIABLE ')' '{' statements_opt '}' {
    $1->type= $4;
    $1->variable= $5;
    $1->statements= $8;
  }
;

finally_opt:
    /* empty */ { $$= NULL; }
  | finally
;
    
finally:
  T_FINALLY  { $1= $yyLex->create(new FinallyNode()); } '{' statements_opt '}' {
    $1->statements= $4;
  }
;
// }}}

// {{{ Expressions
expressionlist_opt:
    /* empty */ { $$= NULL; }
  | expressionlist
;

expressionlist:
    expression { $$= array($1); }
  | expression ',' expressionlist { $$= array_merge(array($1), $3); }
;

expression_opt:
    /* empty */ { $$= NULL; }
  | expression
;

instancecreation:
    typeref '(' expressionlist_opt ')' classbody_opt {
      $$= new InstanceCreationNode();
      $$->type= $1;
      $$->parameters= $3;
      $5 && $$->body= $5;
    }
  | qualifiedname '[' ']' '{' expressionlist_opt '}' {
      $$= new ArrayNode();
      $$->type= new TypeName($1);
      $$->values= $5;
  }
;

staticmember:
    T_WORD { 
      /* TBI: Constant */ 
    }
  | T_VARIABLE { 
      $$= $yyLex->create(new VariableNode($1)); 
    }
  | T_WORD '(' expressionlist_opt ')' { 
      $$= $yyLex->create(new InvocationNode(array('name' => $1))); 
      $$->parameters= $3;
    }
;

expression:
    literal
  | T_VARIABLE { $1= $yyLex->create(new VariableNode($1)); } chain_opt {
      $3 && $1->chained= $3;
    }
  | T_NEW { $p= $yyLex->position; } instancecreation chain_opt { 
      $3->position= $p;
      $4 && $3->chained= $4;
      $$= $3;
    }
  | qualifiedname T_DOUBLE_COLON { $2= $yyLex->create(new ClassMemberNode()); $2->class= new TypeName($1); } staticmember chain_opt {
      $2->member= $4;
      $5 && $2->member->chained= $5;
      $$= $2;
    } 
  | T_WORD '(' { $2= $yyLex->create(new InvocationNode()); } expressionlist_opt ')' chain_opt { 
      $2->name= $1;
      $2->parameters= $4;
      $6 && $2->chained= $6;
      $$= $2;
    }
  | '(' expression ')' { $$= $2; }
  | assignment { 
      $$= $yyLex->create(new AssignmentNode($1)); 
    }
  | comparison { 
      $$= $yyLex->create(new ComparisonNode($1)); 
    }
  | binary_operation { 
      $$= $yyLex->create(new BinaryOpNode($1)); 
    }
  | unary_prefix_operation { 
      $$= $yyLex->create(new UnaryOpNode($1)); 
    }
  | unary_postfix_operation { 
      $$= $yyLex->create(new UnaryOpNode($1)); 
      $$->postfix= TRUE; 
    }
  | expression '?' expression_opt ':' expression { 
      $$= $yyLex->create(new TernaryNode());
      $$->condition= $1;
      $$->expression= $3;
      $$->conditional= $5;
    }
  | expression T_BOOLEAN_OR expression { 
      $$= $yyLex->create(new BinaryOpNode()); 
      $$->lhs= $1; 
      $$->rhs= $3; 
      $$->op= '||'; 
    }
  | expression T_BOOLEAN_AND expression { 
      $$= $yyLex->create(new BinaryOpNode()); 
      $$->lhs= $1; 
      $$->rhs= $3; 
      $$->op= '&&'; 
    }
  | expression T_INSTANCEOF typename {
      $$= $yyLex->create(new InstanceOfNode()); 
      $$->expression= $1; 
      $$->type= $3; 
    }
;

literal:
    T_WORD { /* XXX Constant, e.g. NULL, FALSE, TRUE */ }
  | qualifiedname T_DOUBLE_COLON T_CLASS { /* XXX class literal */ }
  | '[' { $1= $yyLex->create(new ArrayNode()); } expressionlist_opt ']' {
      $1->values= $3;
      $1->type= NULL;   // XXX anytype?
    }
  | '{' mapliteral_opt '}' {
      $$= $yyLex->create(new MapNode());
      $$->elements= $2;
      $$->type= NULL;   // XXX anytype?
    }
  | T_NUMBER { $$= $yyLex->create(new NumberNode()); $$->value= $1; }
  | T_HEX { $$= $yyLex->create(new HexNode()); $$->value= $1; }
  | T_DECIMAL { $$= $yyLex->create(new DecimalNode()); $$->value= $1; }
  | T_STRING { $$= $yyLex->create(new StringNode()); $$->value= $1; }
;

mapliteral_opt:
    /* empty */ { $$= NULL; }
  | mapliteral
;

mapliteral:
    mapentry { $$= array($1); }
  | mapentry ',' mapliteral { $$= array_merge(array($1), $3); }
;

mapentry:
    expression T_DOUBLE_ARROW expression { $$= array($1, $3); }
;

assignment:
    expression '=' expression          /* =  */ { $$= array('variable' => $1, 'expression' => $3, 'op' => $2); }
  | expression T_ADD_EQUAL expression  /* += */ { $$= array('variable' => $1, 'expression' => $3, 'op' => $2); }
  | expression T_SUB_EQUAL expression  /* -= */ { $$= array('variable' => $1, 'expression' => $3, 'op' => $2); }
  | expression T_MUL_EQUAL expression  /* *= */ { $$= array('variable' => $1, 'expression' => $3, 'op' => $2); }
  | expression T_DIV_EQUAL expression  /* /= */ { $$= array('variable' => $1, 'expression' => $3, 'op' => $2); }
  | expression T_MOD_EQUAL expression  /* %= */ { $$= array('variable' => $1, 'expression' => $3, 'op' => $2); }
  | expression T_CONCAT_EQUAL expression  /* ~= */ { $$= array('variable' => $1, 'expression' => $3, 'op' => $2); }
;

comparison:
	expression '<' expression          /* >  */ { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression '>' expression          /* <  */ { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression T_SE expression         /* <= */ { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression T_GE expression         /* >= */ { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression T_EQUALS expression     /* == */ { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression T_NOT_EQUALS expression /* != */ { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
;

binary_operation: 
	expression '+' expression { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression '-' expression { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression '*' expression { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression '/' expression { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression '%' expression { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
  | expression '~' expression { $$= array('lhs' => $1, 'rhs' => $3, 'op' => $2); }
;

unary_prefix_operation:
    '!' expression    { $$= array('expression' => $2, 'op' => $1); }
  | '~' expression    { $$= array('expression' => $2, 'op' => $1); }
  | '+' expression    { $$= array('expression' => $2, 'op' => $1); }
  | '-' expression    { $$= array('expression' => $2, 'op' => $1); }
  | T_INC expression  { $$= array('expression' => $2, 'op' => $1); }
  | T_DEC expression  { $$= array('expression' => $2, 'op' => $1); }
;

unary_postfix_operation:
    expression T_INC { $$= array('expression' => $1, 'op' => $2); }
  | expression T_DEC { $$= array('expression' => $1, 'op' => $2); }
;


chain_opt:
    /* empty */ { $$= NULL; }
  | chained
;

chained:
    chain 
  | chain chained {  $1->chained= $2; }
;

chain:
    '[' { $1= $yyLex->create(new ArrayAccessNode()); } expression_opt ']' { 
      $1->offset= $3;
    }
  | '.' T_WORD {
      $$= $yyLex->create(new VariableNode($2)); 
    }
  | '.' T_WORD '(' { $1= $yyLex->create(new InvocationNode()); } expressionlist_opt ')' { 
      $1->name= $2;
      $1->parameters= $5;
    }
;
// }}}

// {{{ Type name and generics
typeref:
    typename
  | arraytype
;

typename:
    qualifiedname { $$= new TypeName($1); }
  | qualifiedname '<' typeparameters '>' { $$= new TypeName($1, $3); }
;

arraytype:
    qualifiedname '[' ']' { $$= new TypeName($1.'[]'); }
;

typeparameters:
    typeparameter { $$= array($1); }
  | typeparameter ',' typeparameters { $$= array_merge(array($1), $3); }
;

typeparameter:
    typeref
  | '?' T_EXTENDS qualifiedname { $$= new TypeName($3.'+'); }
;

name_list:
    typename { $$= array($1); }
  | typename ',' name_list { $$= array_merge(array($1), $3); }
;
// }}}

// {{{ Modifiers
modifiers_opt:
    /* empty */ { $$= 0; }
  | modifiers   { $$= $1; }
;

modifiers:
    modifier { $$= $1; }
  | modifier modifiers { $$= $1 | $2; }
;

modifier:
	T_PUBLIC    { $$= MODIFIER_PUBLIC; }
  | T_PROTECTED { $$= MODIFIER_PROTECTED; }
  | T_PRIVATE   { $$= MODIFIER_PRIVATE; }
  | T_STATIC    { $$= MODIFIER_STATIC; }
  | T_ABSTRACT  { $$= MODIFIER_ABSTRACT; }
  | T_FINAL     { $$= MODIFIER_FINAL; }
  | T_NATIVE    { $$= MODIFIER_NATIVE; }
  | T_INLINE    { $$= MODIFIER_INLINE; }
;
// }}}

%%
