%{
  uses(
    'peer.sieve.RuleSet',
    'peer.sieve.Rule',
    'peer.sieve.AllOfCondition',
    'peer.sieve.NegationOfCondition',
    'peer.sieve.AnyOfCondition',
    'peer.sieve.BooleanCondition'
  );
%}

%token T_WORD 260
%token T_STRING 261

%token T_REQUIRE 270

%token T_IF 280
%token T_ELSEIF 281

%token T_ALLOF 290
%token T_ANYOF 291
%token T_NOT 292

%token T_HEADER 300
%token T_SIZE 301
%token T_ADDRESS 302
%token T_TRUE 303
%token T_FALSE 304

%%

start:
    requires_opt rules_opt {
      $$= new peer新ieve愛uleSet();
      $$->required= $1;
      $$->rules= $2;
    }
;

// {{{ Required items
requires_opt:
    /* empty */ { $$= NULL; }
  | requires 
;

requires:
    require { $$= $1; }
  | require requires { $$= array_merge(array($1), $2); }
;

require:
    T_REQUIRE '[' stringlist ']' ';' { $$= $3; }
;
// }}}

// {{{ Rules
rules_opt:
    /* empty */ { $$= NULL; }
  | rules 
;

rules:
    rule { $$= array($1); }
  | rule rules { $$= array_merge(array($1), $2); }
;

rule:
    T_IF { $1= new peer新ieve愛ule(); } test '{' statements '}' else_opt {
      $$->condition= $3;
      $$->statements= $5;
    }
;

else_opt:
    /* empty */ { $$= NULL; }
  | T_ELSEIF test '{' statements '}' else_opt
;
// }}}

statements:
    statement { $$= array($1); }
  | statement statements { $$= array_merge(array($1), $2); }
;

statement:
    T_WORD ';'
  | T_WORD T_STRING ';'
;

// {{{ Tests
//     E.g. allof (address :regex ["From"] "bug[\-\+](.*)?@laudi\.de")
test:
    T_ALLOF { $1= $yyLex->create(new AllOfCondition()); } '(' testlist ')' {
      $1->expressions= $4;
    }
  | T_ANYOF { $1= $yyLex->create(new AnyOfCondition()); } '(' testlist ')' {
      $1->expressions= $4;
    }
  | T_NOT { $1= $yyLex->create(new NegationOfCondition()); } test {
      $1->condition= $2;
    }
  | T_HEADER ':' T_WORD arguments { 
      $$= array($1 => array($3, $4)); 
    }
  | T_SIZE ':' T_WORD arguments {
      $$= array($1 => array($3, $4)); 
    }
  | T_ADDRESS ':' T_WORD arguments {
      $$= array($1 => array($3, $4)); 
    }
  | T_TRUE { 
      $$= $yyLex->create(new BooleanCondition(TRUE));
    }
  | T_FALSE { 
      $$= $yyLex->create(new BooleanCondition(FALSE));
    }
;

testlist:
    test { $$= array($1); }
  | test ',' testlist { $$= array_merge(array($1), $3); }
;

arguments:
    argument { $$= array($1); }
  | argument arguments { $$= array_merge(array($1), $2); }
;

argument:
    T_STRING
//  | T_NUMBER
  | '[' stringlist ']'
;

// }}}


// {{{ List of strings
stringlist:
    T_STRING { $$= array($1); }
  | T_STRING ',' stringlist  { $$= array_merge(array($1), $3); }
;

// }}}
%%
