/* This class is part of the XP framework
 *
 * $Id$ 
 */

package de.thekid.rfc2github;

import peer.http.*;
import io.collections.FileCollection;
import io.collections.iterate.*;
import text.regex.*;
import lang.types.String;

import native standard.strtok;
import native standard.trim;
import native standard.ltrim;
import native standard.explode;
import native standard.sscanf;
import native standard.substr;
import native pcre.preg_replace;
import native core.strncmp;
import native core.strlen;
import native standard.strstr;

/**
 * Migrates RFCs by a given author
 *
 */
public class MigrateRfcsByAuthor extends GitHubApiCommand {
  protected string $author;
  protected IOCollectionIterator $origin;
  
  /**
   * Sets origin filename
   *
   */
  [@arg(position= 1)]
  public void setOriginFolder(string $name) {
    $this.origin= new FilteredIOCollectionIterator(
      new FileCollection($name), 
      new NameMatchesFilter('/[0-9]+.rfc.txt/')
    );
  }
  
  /**
   * Sets author
   *
   */
  [@arg(position= 2)]
  public void setAuthor(string $name) {
    $this.author= $name;
  }

  /**
   * Sets target (owner/repo)
   *
   */
  [@arg(position= 3)]
  public void setTarget(string $target) {
    $owner= $repo= null;
    sscanf($target, "%[^/]/%[^\r]", $owner, $repo);
    $this.parameters= [ user: $owner, repo: $repo ];
  }


  /**
   * Syntactic rewrite: XP markup -> Github syntax
   *
   */
  protected string rewrite(string $line) {
    if (0 === strncmp('---', $line, 3)) {
      $line= '====';
    } else if (0 === strncmp('~~~', $line, 3)) {
      $line= '----';
    } else if ('<code>' === $line) {
      $line= "\n```php\n<?php";
    } else if ('</code>' === $line) {
      $line= "?>\n```";
    } else if ('<pre>' === $line || '</pre>' === $line) {
      $line= "\n```";
    } else if ('<EOF>' === $line) {
      $line= '';
    }

    return preg_replace(
      [ '#<tt>#', '#</tt>#', '/RFC #([0-9]+)/e'],
      [ '`', '`', '"xp-framework/rfc #".ltrim("\1", "0")'],
      $line
    ) ~ "\n";
  }
  
  /**
   * Parse an RFC
   *
   */
  protected [:var] parseRfc(io.streams.InputStream $in) {
    $fields= [:];
    $id= $caption= null;
    with ($st= new text.StreamTokenizer($in, "\r\n")) {
      $title= $st.nextToken();
      sscanf($title, "RFC %4s: %[^\r]", $id, $caption);
      $st.nextToken('@');
      
      while ($st.hasMoreTokens()) {
        if ('' === ($t= ltrim($st.nextToken(), '@'))) break;   // End of attributes

        $key= $value= null;
        sscanf($t, "%[^:]: %[^\r]", $key, $value);

        switch ($key) {
          case 'status':
            $fields['status.id']= strtok($value, ',( ');
            $fields['status.text']= trim(strtok("\0"));
            break;

          case 'authors':
            $fields['authors']= explode(', ', $value);
            break;

          case 'created':
            $fields['created']= util.Date::fromString($value);
            break;

          case 'category':
            $fields['category']= trim($value, '<>');
            break;
            
          default:
            $fields[$key]= $value;
            break;
        }
      }

      // Rest of text (use a token that is not very likely to appear so
      // scanning will happen in large chunks).
      $content= '';
      while ($st.hasMoreTokens()) {
        $line= $st.nextToken();
        if ('Comments' === $line) break;

        $content ~= $this.rewrite($line);
      }

      // Parse Commments
      $st.nextToken();
      $comment= $last= null;
      $comments= [:];
      with ($separator= new Pattern('([a-z]+), ([a-zA-Z0-9:,+ ]+ [0-9]{4})(.*)')) {
        while ($st.hasMoreTokens()) {
          $last= $line;
          $line= $st.nextToken();

          // Old format: "- <USER>, <DATE>\n<LINE1>\n<LINE2>...\n"
          if (0 === strncmp('- ', $line, 2) && !MatchResult::$EMPTY.equals($match= $separator.match(substr($line, 2)))) {
            $comment && $comments[$comment['id']]= $comment['content'];
            $comment= [
              id      : $match.group(0)[1] ~ ', ' ~ new util.Date($match.group(0)[2]).toString('r'),
              content : $match.group(0)[3]
            ];
            continue;
          }

          // New format: "<USER>, <DATE>\n~~~~...\n<LINE1>\n<LINE2>...\n"
          if (0 === strncmp('~~~', $line, 3) && !MatchResult::$EMPTY.equals($match= $separator.match($last))) {
            $comment && $comments[$comment['id']]= substr($comment['content'], 0, -strlen($last)- 1);
            $comment= [
              id      : $match.group(0)[1] ~ ', ' ~ new util.Date($match.group(0)[2]).toString('r'),
              content : ''
            ];
            continue;
          }

          if (null === $comment) continue;
          $comment['content']~= $this.rewrite(trim($line));
        }
        $comment && $comments[$comment['id']]= $comment['content'];
      }
    }
    
    return [ 
      id       : $id, 
      caption  : $caption, 
      fields   : $fields, 
      content  : $content, 
      comments : $comments 
    ];
  }

  protected static var $state = [
    draft :       'open',
    discussion :  'open',
    rejected :    'closed',
    obsoleted :   'closed',
    implemented:  'closed',
  ];
  
  /**
   * Modify an issue
   *
   */
  protected [:var] modifyIssue(HttpRequest $request, int $expect, string $title, string $content, [:var] $fields) {
    $labels= [ $fields['status.id'] ];

    // Map category to labels
    if (strstr($fields['category'], '<core>')) {
      $labels[]= 'framework';
    } else if (strstr($fields['category'], '<language>')) {
      $labels[]= 'language';
    } else if (strstr($fields['category'], '<infrastructure>')) {
      $labels[]= 'technology';
    } else if (strstr($fields['category'], '<strategy>')) {
      // Nothing
    } else if (strstr($fields['category'], '<ports>')) {
      $labels[]= 'contrib';
    } else {
      $labels[]= 'framework';
    }

    // Create request
    $request.setParameters(new RequestData(self::$json.encode([
      title  : new String($title),
      body   : new String($content),
      state  : self::$state[$fields['status.id']],
      labels : $labels
    ])));
    $request.setHeader('Content-Type', 'application/vnd.github-issue.raw+json');

    $response= $this.sendApiRequest($request);
    if ($expect != $response.status()) {
      throw new IllegalArgumentException($response.toString());
    }

    return $response.result() as [:var];
  }

  /**
   * Creates an issue
   *
   */
  protected [:var] createIssue(string $title, string $content, [:var] $fields) {
    return $this.modifyIssue(
      $this.newApiRequest(HttpConstants::POST, '/repos/:user/:repo/issues'), 
      201, 
      $title, 
      $content, 
      $fields
    );
  }

  /**
   * Updates an existing issue
   *
   */
  protected [:var] updateIssue(int $id, string $title, string $content, [:var] $fields) {
    return $this.modifyIssue(
      $this.newApiRequest(HttpConstants::PATCH, '/repos/:user/:repo/issues/:id', [ id: $id ]),
      200, 
      $title, 
      $content, 
      $fields
    );
  }

  /**
   * Entry point method
   *
   */
  public void run() {
    $this.out.writeLine('===> RFCs by ', $this.author, ' in ', $this.origin);
    foreach ($file in $this.origin) {
      $rfc= $this.parseRfc($file.getInputStream());
      if ($this.author !== $rfc['fields']['authors'][0]) continue;
      
      $this.out.writeLine('---> ', $rfc['id'], ': ', $rfc['caption'], ' (', $rfc['fields']['status.id'], ')');
      
      // Check GH for corresponding issue
      $response= $this.sendApiRequest($this.newApiRequest(HttpConstants::GET, '/repos/:user/:repo/issues/:id', [ id : $rfc['id'] ]));
      if (200 != $response.status()) {
        $this.err.writeLine('     >> Not found');
        break;
      }

      // Found it, update
      $issue= $response.result() as [:var];

      $this.out.write('     >> Found existing issue #', $issue['number']);
      $this.updateIssue($issue['number'], $rfc['caption'], $rfc['content'], $rfc['fields']);
      $this.out.writeLine(': Updated');

      // Get existing comments
      $response= $this.sendApiRequest($this.newApiRequest(HttpConstants::GET, '/repos/:user/:repo/issues/:id/comments', [ id : $issue['number'] ]));
      $list= $response.result() as [:var][];
      $existing= [:];
      foreach ($i, $item in $list) {
        if (MatchResult::$EMPTY.equals($match= $separator.match($item['body']))) continue;

        $key= $match.group(0)[1] ~ ', ' ~ new util.Date($match.group(0)[2]).toString('r');
        if (isset($comments[$key])) {
          unset($comments[$key]);
        } else {
          $this.out.write('     >> Comments -= ', $key);
          $delete= $this.newApiRequest(HttpConstants::DELETE, '/repos/:user/:repo/issues/comments/:id', [ id : $item['id'] ]);
          $r= $this.sendApiRequest($delete);
          $this.out.writeLine($r.status());
        }
      }

      // Add comments from origin RFC
      foreach ($key, $add in $comments) {
        $this.out.write('     >> Comments += ', $key, ': ');
        $create= $this.newApiRequest(HttpConstants::POST, '/repos/:user/:repo/issues/:id/comments', [ id : $issue['number'] ]);
        $create.setParameters(new RequestData(self::$json.encode([
          body : new String($add).concat("\n").concat($key)
        ])));
        $create.setHeader('Content-Type', 'application/vnd.github-issuecomment.raw+json');
        $r= $this.sendApiRequest($create);
        $this.out.writeLine($r.status());
      }
    }
  }
}
