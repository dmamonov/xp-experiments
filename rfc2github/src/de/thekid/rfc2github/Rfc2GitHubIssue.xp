/* This class is part of the XP framework
 *
 * $Id$ 
 */

package de.thekid.rfc2github;

import peer.http.*;
import io.File;
import lang.types.String;

import native standard.sscanf;
import native standard.strtok;
import native standard.explode;
import native standard.trim;
import native standard.ltrim;
import native standard.urlencode;
import native standard.substr;
import native standard.max;
import native standard.sprintf;
import native standard.array_diff;

import native pcre.preg_replace;

import native core.strncmp;
import native core.strlen;

/**
 * Imports XP Framework RFCs to Github issues
 *
 * @see      http://develop.github.com/p/issues.html
 * @see      https://github.com/thekid/experiments/issues
 */
public class Rfc2GitHubIssue extends util.cmd.Command {
  protected File $origin;
  protected HttpConnection $conn= new HttpConnection('http://github.com');
  protected [:string] $identity;
  protected string $target;
  
  /**
   * Sets origin filename
   *
   */
  [@arg(position= 0)]
  public void setOriginFile(string $file) {
    $this.origin= new File($file);
  }

  /**
   * Sets target (user:token@owner/repo)
   *
   */
  [@arg(position= 1)]
  public void setTarget(string $target) {
    $user= $token= $owner= $repo= null;
    sscanf($target, "%[^:]:%[^@]@%[^/]/%[^\r]", $user, $token, $owner, $repo);
    
    $this.identity= [login : $user, token : $token];
    $this.target= $owner ~ '/' ~ $repo;
  }
  
  /**
   * Creates a new API request
   *
   */
  protected HttpRequest newApiRequest(string $method, string $area, [:string] $parameters= [:]) {
    $request= $this.conn.create(new HttpRequest());
    $request.setMethod($method);
    $target= '/api/v2/json/' ~ $area ~ '/' ~ $this.target;
    foreach ($value in $parameters) {
      $target ~= '/' ~ urlencode($value);
    }
    $request.setTarget($target);
    $request.setParameters($this.identity);
    return $request;
  }

  /**
   * Creates a new API request
   *
   */
  protected ApiResponse sendApiRequest(HttpRequest $request) {
    return new ApiResponse($this.conn.send($request));
  }
  
  protected static [:string] $state = [
    draft :       'open',
    discussion :  'open',
    rejected :    'closed',
    obsoleted :   'closed',
    implemented:  'closed',
  ];
  
  /**
   * Synchronize meta information
   *
   */
  protected void syncMeta([:var] $issue, [:var] $fields) {
  
    // 1: Labels
    $labels= ['rfc', $fields['status.id']];
    foreach ($label in array_diff($labels, $issue['labels']) as var[]) {
      $this.out.writeLine('Adding label ', $label);
      $this.sendApiRequest($this.newApiRequest(HttpConstants::POST, 'issues/label/add', [
        label  : $label, 
        number : $issue['number']
      ]));
    }
    foreach ($label in array_diff($issue['labels'], $labels) as var[]) {
      $this.out.writeLine('Removing label ', $label);
      $this.sendApiRequest($this.newApiRequest(HttpConstants::POST, 'issues/label/remove', [
        label  : $label, 
        number : $issue['number']
      ]));
    }
    
    // 2: Status
    $state= self::$state[$fields['status.id']];
    if ('closed' == $state && 'open' == $issue['state']) {
      $this.out.writeLine('Closing issue');
      $this.sendApiRequest($this.newApiRequest(HttpConstants::POST, 'issues/close', [number: $issue['number']]));
    } else if ('open' == $state && 'closed' == $issue['state']) {
      $this.out.writeLine('Reopening issue');
      $this.sendApiRequest($this.newApiRequest(HttpConstants::POST, 'issues/reopen', [number: $issue['number']]));
    }
  }

  /**
   * Creates an issue
   *
   */
  protected [:var] createIssue(string $title, string $content, [:var] $fields) {
    $create= $this.newApiRequest(HttpConstants::POST, 'issues/open');
    $create.setParameter('title', $title);
    $create.setParameter('body', $content);
    $response= $this.sendApiRequest($create);
    if (201 != $response.status()) {
      throw new IllegalArgumentException($response.toString());
    }
    $created= $response.result()['issue'] as [:var];
    
    $this.syncMeta($created, $fields);
    return $created;
  }

  /**
   * Updates an existing issue
   *
   */
  protected [:var] updateIssue(int $id, string $title, string $content, [:var] $fields) {
    $update= $this.newApiRequest(HttpConstants::POST, 'issues/edit', [number: $id]);
    $update.setParameter('title', new String($title).getBytes('utf-8'));
    $update.setParameter('body', new String($content).getBytes('utf-8'));
    $response= $this.sendApiRequest($update);
    if (200 != $response.status()) {
      throw new IllegalArgumentException($response.toString());
    }

    $updated= $response.result()['issue'] as [:var];
    
    $this.syncMeta($updated, $fields);
    return $updated;
  }
  
  /**
   * Entry point method
   *
   */
  public void run() {
  
    // Parse RFC into caption, fields and body text
    $fields= [:];
    with ($st= new text.StreamTokenizer($this.origin.getInputStream(), "\r\n")) {
      $title= $st.nextToken();
      $id= $caption= null;
      sscanf($title, "RFC %4s: %[^\r]", $id, $caption);
      $st.nextToken('@');
      
      while ($st.hasMoreTokens()) {
        if ('' === ($t= ltrim($st.nextToken(), '@'))) break;   // End of attributes

        $key= $value= null;
        sscanf($t, "%[^:]: %[^\r]", $key, $value);

        switch ($key) {
          case 'status':
            $fields['status.id']= strtok($value, ',( ');
            $fields['status.text']= strtok("\0");
            break;

          case 'authors':
            $fields['authors']= explode(', ', $value);
            break;

          case 'created':
            $fields['created']= util.Date::fromString($value);
            break;

          case 'category':
            $fields['category']= trim($value, '<>');
            break;
            
          default:
            $fields[$key]= $value;
            break;
        }
      }

      // Rest of text (use a token that is not very likely to appear so
      // scanning will happen in large chunks).
      $content= '';
      while ($st.hasMoreTokens()) {
        $line= $st.nextToken();
        if (0 === strncmp('---', $line, 3)) {
          $line= '====';
        } else if (0 === strncmp('~~~', $line, 3)) {
          $line= '----';
        } else if ('<code>' === $line) {
          $line= "\n```php\n<?php";
        } else if ('</code>' === $line) {
          $line= "?>\n```";
        } else if ('<pre>' === $line || '</pre>' === $line) {
          $line= "\n```";
        }

        $content ~= preg_replace(
          [ '#<tt>#', '#</tt>#', '/RFC #([0-9]+)/e'],
          [ '`', '`', '"xp-framework/rfc #".ltrim("\1", "0")'],
          $line
        ) ~ "\n";
      }
    }
    
    $this.out.writeLine('#', $id, ': ', $caption, ' ', $fields);
    // $this.out.writeLine($content);
    
    // Check GH for corresponding issue
    $response= $this.sendApiRequest($this.newApiRequest(HttpConstants::GET, 'issues/list', [
      by    : 'label',
      label : 'rfc'
    ]));
    $issues= $response.result()['issues'] as [:var][];
    $last= 0;
    foreach ($issue in $issues) {
      $last= max($issue['number'], $last);
      if ($id != $issue['number']) continue;
      
      // Found it, update and exit
      $this.out.writeLine('Found existing issue #', $issue['number']);
      $this.updateIssue($issue['number'], $title, $content, $fields);
      $this.out.writeLine('Updated issue #', $issue['number']);
      return 0;
    }
    
    // Not found, create placeholders
    $i= ltrim($id, '0') as int;
    $this.out.writeLine('Creating place holder RFCs for ', $last, ' .. ', $i);
    while (++$last < $i) {
      $this.createIssue(sprintf('RFC %04d: ...', $last), '.', [ status : 'placeholder' ]);
    }
    
    // Now create the real issue
    $this.out.writeLine('Nothing found, creating new issue');
    $issue= $this.createIssue($title, $content, $fields);
    $this.out.writeLine('Created issue #', $issue['number']);
    return 0;
  }
}
